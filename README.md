
# create a parameter list
``` r
params <- list()
To create a connection object, you need to define a list of parameters that will be passed as arguments. 
This can be done by creating an empty list object and assigning it to a variable named 'params'.
example parameters : api_key = "", api_secret = "", request_token = "".
```

# make a call to create_connection_object
``` r
Once you have defined the necessary parameters in the 'params' list, you can pass them to the 'create_connection_object()' function to create a new connection object. The function will return an object of the 'sharekhanconnect' type, which can then be assigned to a variable named connect.
connect <- create_connection_object(params = params)
```

# make a call to get_login_url print the login url
``` r
The 'get_login_url()' function requires two parameters: an object of type 'sharekhanconnect' and a 'vendor_key' (which has a default value of NULL). 
To call the function and generate a login URL, you should first pass the sharekhanconnect object (connect) to the function as follows: 
'url <- get_login_url(connect)'. If a vendor key is required, you should also pass it as an argument to the function.
```

# decryption-encryption and access token
``` r
After Successfully Login You will receive the request token value then you have to decrypt the token value by using secret key and then swap the request token which is a combination of RequestId and CustomerId Then after that decrypt the request token value(you can pass it to above params list)
We will pass the sharekhanconnect type object to 'fetch_access_token' in which we have encryption-decryption logic and by successful run it will return
a response which contain out access token
```

# place order history
```r
new_order_method_params={ "customerId": XXXXXX, "scripCode": XXXXXX, "tradingSymbol": "ONGC", "exchange": "NC", "transactionType": "B", "quantity": 1, "disclosedQty": 0, "price": "145.85", "triggerPrice": "0", "rmsCode": "ANY", "afterHour": "N", "orderType": "NORMAL", "channelUser": "XXXXXX", "validity": "GFD", "requestType": "NEW", "productType": "CNC" }
new_order_response <- place_order(connect, new_order_method_params)
new_order_response
```

# Retrieves all positions
```r
trade_params = list("customerId" = XXXXXX)
trade_position_response <- get_trade_position(connect, trade_params)
# trade_position_response
```

# Retrieve history of an given order
```r
report_method_params = list(
   "exchange" = "NC",
   "customerId" = XXXXXX,
   "orderId" = "XXXXXX"
   )
report_order_response <- get_report_history(connect, report_method_params)
report_order_response
```

# Retrieves the trade generated by an order
```r
report_method_params = list(
   "exchange" = "NC",
   "customerId" = XXXXXX,
   "orderId" = "XXXXXX"
   )
report_trade_response <- get_report_trade(connect, report_method_params)
report_trade_response
```

# services Holdings
```r
holdings_params = list("customerId" = XXXXXX)
holdings_response <- get_holdings(connect, holdings_params)
holdings_response
```

# Script Master
```r
master_params = list("exchange" = "NC")
master_response <- get_master(connect, master_params)
master_response
```

# Historical Data
```r
historical_method_params = list(
  "exchange" = "NC",
  "scripcode" = XXX,
  "interval" = "daily"
)
historical_reaponse <- get_historical(connect, historical_method_params)
historical_reaponse
```

# websocket Programming Testing
```r
For websocket we have to first define some parameters in 'params' we can send those
params which contains other necessary parameters also to 'socketObject <- sharekhan_connect_object(params)'
which return sharekhanwebSocket type object in response and then we send it to
'sharekhanSocket.connect(socketObject)' and make a call.

Functions : fetch_data and send_ticks. 
fetch_data sends a JSON-encoded message to the server using the WebSocket object, with the contents of the message 
including the values of action, key, and value from the sharekhanwebSocket object.
send_ticks sends a "heartbeat" message to the server every 10 seconds, using the later package to schedule the message 
to be sent repeatedly.

Event handlers : onOpen, onMessage, and onError events of the WebSocket object.
ws$onOpen(function(event){
    is_open<-TRUE
    message("connection is opened")
    fetch_data()
    send_ticks()
  })
  fetch_data<-function(){
    message("Fetching data")
    ws$send(toJSON(list("action" = object@action,"key" = object@key, "value" = object@value), auto_unbox = TRUE))
  }
  send_ticks<-function(){
    message("heartbeat")
    later::later(send_ticks,10)
  }
  ws$onMessage(function(event) {
    message(base64enc::base64decode(event$data))
    msg_data <- event$data
    cat("Client received message: \n",msg_data, "\n")

  })
  ws$onError(function(){
    cat("Error in the connection")
  })
  ws$connect()

```


